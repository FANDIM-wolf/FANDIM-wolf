    //Листинг #3        Односвязные списки          Borland C++ 3.1
 #include <conio.h>
#include <iostream.h>
 
struct element                  //Структура с инфополями и адресным полем
{
 int x;                         //Инфополе. значения из x будут передаваться в список
 element *Next;                 //Адресное поле
};
 
class List                      //Класс Список
{
 element *Head;                 //Указатель на последний активный элемент или просто голова списка
 public:
  List() {Head=NULL;}           //Конструктор и инициализация указателя пустым значением
 ~List();                       //Деструктор. Далее он вынесен за класс
 void Add(int x);               //Функция для добавления значений в список
 void Show();                   //Функция для отображения списка на экране
};
 
List::~List()                   //Деструктор вынесен за класс
{
    while (Head!=NULL)          //Пока по адресу не пусто
     {
        element *temp = Head->Next;   //Временная переменная для хранения адреса следующего элемента
        delete Head;                //Освобождаем адрес обозначающий начало
        Head = temp;                  //Меняем адрес на следующий
     }
}
 
void List::Add(int x) //Функция добавления элементов в список
{
element *temp = new element;           //При каждом вызове выделяется память
temp->x = x;                            //Записываем x в элемент структуры  element (в x структуры element)
temp->Next = Head;                      //Указываем, что след. элемент это объект по адресу Head
Head = temp;                            //Указываем, что последний активный элемент это только что введенный
}
 
 
 
void List::Show()                       //Функция отображения списка на экране
{
  element *temp = Head;                 //Определяем указатель, который изначально он равен адресу начала списка
 
 
 while (temp != NULL)                   //До тех пор пока не встретит пустое значение
 {
  cout << temp->x << " ";               //Выведет элемент x из списка
  temp = temp->Next;                    //Указываем, что далее нам нужен следующий элемент
 }
}
 
int main()
{
 clrscr();
 
 cin.get();
 return 0;
}